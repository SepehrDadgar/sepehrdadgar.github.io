<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>Pure JS WebGL OBJ Viewer â€” Hovering</title>
<style>
html,body {margin:0;height:100%;background:#0b0f14;overflow:hidden}
#gl {width:100%;height:100%;display:block}

</style>
</head>
<body>
<canvas id="gl"></canvas>
<script>
const OBJ_URL = "model.obj"; // <-- put your .obj file path here

const gl = document.getElementById("gl").getContext("webgl",{antialias:true});
if(!gl) alert("WebGL not supported");

function loadOBJ(text) {
  let positions=[],normals=[],finalPos=[],finalNorm=[];
  let tempPos=[[0,0,0]],tempNorm=[[0,0,0]];
  const lines=text.split("\n");
  for(let line of lines){
    let p=line.trim().split(/\s+/);
    if(p[0]==="v") tempPos.push(p.slice(1).map(Number));
    else if(p[0]==="vn") tempNorm.push(p.slice(1).map(Number));
    else if(p[0]==="f"){
      for(let i=1;i<=3;i++){
        const [vi,,ni]=p[i].split("/").map(Number);
        const v=tempPos[vi], n=tempNorm[ni];
        finalPos.push(...v); finalNorm.push(...n);
      }
    }
  }
  return {pos:new Float32Array(finalPos), norm:new Float32Array(finalNorm)};
}

function makeShader(type,src){
  const s=gl.createShader(type);
  gl.shaderSource(s,src); gl.compileShader(s);
  if(!gl.getShaderParameter(s,gl.COMPILE_STATUS))
    throw gl.getShaderInfoLog(s);
  return s;
}
const vsSrc=`
attribute vec3 aPos,aNorm;
uniform mat4 uProj,uView,uModel;
uniform mat3 uNormMat;
varying vec3 vNorm,vPos;
void main(){
  vec4 world=uModel*vec4(aPos,1.0);
  vPos=world.xyz;
  vNorm=normalize(uNormMat*aNorm);
  gl_Position=uProj*uView*world;
}`;
const fsSrc=`
precision mediump float;
varying vec3 vNorm,vPos;
uniform vec3 uLightDir,uCam;
void main(){
  vec3 N=normalize(vNorm);
  vec3 L=normalize(-uLightDir);
  float diff=max(dot(N,L),0.0);
  vec3 V=normalize(uCam-vPos);
  vec3 R=reflect(-L,N);
  float spec=pow(max(dot(R,V),0.0),32.0)*0.3;
  vec3 color=vec3(0.3,0.6,0.9)*(0.15+diff)+spec;
  gl_FragColor=vec4(color,1.0);
}`;
const prog=gl.createProgram();
gl.attachShader(prog,makeShader(gl.VERTEX_SHADER,vsSrc));
gl.attachShader(prog,makeShader(gl.FRAGMENT_SHADER,fsSrc));
gl.linkProgram(prog);
if(!gl.getProgramParameter(prog,gl.LINK_STATUS))
  throw gl.getProgramInfoLog(prog);
gl.useProgram(prog);

function loc(name){return gl.getAttribLocation(prog,name);}
function uloc(name){return gl.getUniformLocation(prog,name);}
const aPos=loc("aPos"),aNorm=loc("aNorm");
const uProj=uloc("uProj"),uView=uloc("uView"),uModel=uloc("uModel"),uNormMat=uloc("uNormMat");
const uLightDir=uloc("uLightDir"),uCam=uloc("uCam");

function mat4Identity(){return [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];}
function mat4Multiply(a,b){
  let o=new Array(16);
  for(let r=0;r<4;r++)for(let c=0;c<4;c++)
    o[c+r*4]=a[r*4]*b[c]+a[r*4+1]*b[c+4]+a[r*4+2]*b[c+8]+a[r*4+3]*b[c+12];
  return o;
}
function mat4Translate(x,y,z){let m=mat4Identity();m[12]=x;m[13]=y;m[14]=z;return m;}
function mat4RotateY(rad){let c=Math.cos(rad),s=Math.sin(rad);
  return [c,0,-s,0, 0,1,0,0, s,0,c,0, 0,0,0,1];}
function mat4RotateX(rad){let c=Math.cos(rad),s=Math.sin(rad);
  return [1,0,0,0, 0,c,s,0, 0,-s,c,0, 0,0,0,1];}
function mat4Perspective(fovy,aspect,near,far){
  let f=1/Math.tan(fovy/2), nf=1/(near-far);
  let o=mat4Identity();
  o[0]=f/aspect; o[5]=f; o[10]=(far+near)*nf; o[11]=-1; o[14]=(2*far*near)*nf; o[15]=0;
  return o;
}
function mat3FromMat4(m){return [m[0],m[1],m[2], m[4],m[5],m[6], m[8],m[9],m[10]];}
function mat3InvertTranspose(m){
  let a=m[0],b=m[1],c=m[2],d=m[3],e=m[4],f=m[5],g=m[6],h=m[7],i=m[8];
  let A=e*i-f*h, B=c*h-b*i, C=b*f-c*e, D=f*g-d*i, E=a*i-c*g, F=c*d-a*f, G=d*h-e*g, H=b*g-a*h, I=a*e-b*d;
  let det=a*A+b*D+c*G; if(!det)det=1; det=1/det;
  return [A*det,-B*det,C*det, -D*det,E*det,-F*det, G*det,-H*det,I*det];
}
function normalize(v){let l=Math.hypot(...v)||1;return v.map(x=>x/l);}
function cross(a,b){return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]];}
function dot(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2];}

let yaw=0.5,pitch=0,dist=3;
let isDown=false,lastX,lastY;
gl.canvas.addEventListener("mousedown",e=>{isDown=true;lastX=e.clientX;lastY=e.clientY;});
window.addEventListener("mouseup",()=>isDown=false);
window.addEventListener("mousemove",e=>{
  if(!isDown)return;
  yaw+=(e.clientX-lastX)/200;
  pitch=Math.max(-1.3,Math.min(1.3,pitch+(e.clientY-lastY)/200));
  lastX=e.clientX;lastY=e.clientY;
});
gl.canvas.addEventListener("wheel",e=>{
  dist*=1+Math.sign(e.deltaY)*0.1;
  dist=Math.max(1,Math.min(10,dist));
  e.preventDefault();
},{passive:false});

function getView(){let cx=dist*Math.cos(pitch)*Math.sin(yaw),
cy=dist*Math.sin(pitch),cz=dist*Math.cos(pitch)*Math.cos(yaw);
let up=[0,1,0],z=normalize([cx,cy,cz]),x=normalize(cross(up,z)),y=cross(z,x);
return {view:[x[0],y[0],z[0],0, x[1],y[1],z[1],0, x[2],y[2],z[2],0, -dot(x,[cx,cy,cz]),-dot(y,[cx,cy,cz]),-dot(z,[cx,cy,cz]),1], cam:[cx,cy,cz]}}

gl.enable(gl.DEPTH_TEST); gl.clearColor(0.992, 0.992, 0.992, 1.0);
;

fetch(OBJ_URL).then(r=>r.text()).then(text=>{
  const model=loadOBJ(text);
  const posBuf=gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER,posBuf);
  gl.bufferData(gl.ARRAY_BUFFER,model.pos,gl.STATIC_DRAW);
  gl.vertexAttribPointer(aPos,3,gl.FLOAT,false,0,0);
  gl.enableVertexAttribArray(aPos);

  const normBuf=gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER,normBuf);
  gl.bufferData(gl.ARRAY_BUFFER,model.norm,gl.STATIC_DRAW);
  gl.vertexAttribPointer(aNorm,3,gl.FLOAT,false,0,0);
  gl.enableVertexAttribArray(aNorm);

  const lightDir=normalize([-0.5,-1,-0.8]);
  let start=performance.now();
  function render(now){
    let t=(now-start)/1000;
    gl.viewport(0,0,gl.canvas.width=innerWidth,gl.canvas.height=innerHeight);
    gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
    const proj=mat4Perspective(Math.PI/4,gl.canvas.width/gl.canvas.height,0.01,100);
    const {view,cam}=getView();
    const hoverY=Math.sin(t*2)*0.3;
    const modelMat=mat4Multiply(mat4Translate(0,hoverY,0),mat4Multiply(mat4RotateY(t*0.8),mat4RotateX(t*0.3)));
    const normMat=mat3InvertTranspose(mat3FromMat4(modelMat));
    gl.uniformMatrix4fv(uProj,false,new Float32Array(proj));
    gl.uniformMatrix4fv(uView,false,new Float32Array(view));
    gl.uniformMatrix4fv(uModel,false,new Float32Array(modelMat));
    gl.uniformMatrix3fv(uNormMat,false,new Float32Array(normMat));
    gl.uniform3fv(uLightDir,new Float32Array(lightDir));
    gl.uniform3fv(uCam,new Float32Array(cam));
    gl.drawArrays(gl.TRIANGLES,0,model.pos.length/3);
    requestAnimationFrame(render);
  }
  render();
});
</script>
</body>
</html>
